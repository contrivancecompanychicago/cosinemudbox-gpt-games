<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puyo Puyo Simplified</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
        }

        canvas {
            border: 1px solid black;
        }

        #controls {
            margin-top: 10px;
        }

        button {
            margin: 5px;
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas" width="240" height="480"></canvas>

    <div id="controls">
        <button onclick="startGame()">Start</button>
        <button onclick="pauseGame()">Pause</button>
        Score: <span id="score">0</span> | High Score: <span id="highScore">0</span>
    </div>
    <div id="instructions">
        <h2>How to Play:</h2>
        <ul>
            <li><b>Start:</b> Click the Start button to begin the game.</li>
            <li><b>Pause:</b> Click the Pause button to pause the game.</li>
            <li><b>Move Left:</b> Press the "A" key or the left arrow key.</li>
            <li><b>Move Right:</b> Press the "D" key or the right arrow key.</li>
            <li><b>Move Down Faster:</b> Press the "S" key or the down arrow key.</li>
            <li><b>Rotate Blocks:</b> Press the up arrow key to rotate the blocks.</li>
            <li>Stack the blocks and try to get 4 or more of the same color in a row horizontally or vertically to
                remove them.</li>
            <li>The game progresses with blocks falling from the top. Your objective is to strategically place these
                blocks without letting them overflow. Once a pair of blocks can't fit into the play area, the game ends.
            </li>
            <li>Score points by removing blocks. The more blocks you remove at once, the higher your score!</li>
        </ul>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const grid = [];
        const gridSize = 30;
        const gridRows = canvas.height / gridSize;
        const gridCols = canvas.width / gridSize;
        let score = 0;
        let highScore = localStorage.getItem('highScore') || 0;
        document.getElementById('highScore').innerText = highScore;
        let currentBlock = null;
        let gameInterval;

        class BlockPair {
            constructor() {
                this.primary = {
                    row: 0,
                    col: Math.floor(gridCols / 2),
                    color: this.randomColor()
                };
                this.secondary = {
                    row: -1,
                    col: Math.floor(gridCols / 2),
                    color: this.randomColor()
                };
                this.rotationState = 0;  // Initialize to 0
            }

            rotate() {
                let newRow = this.secondary.row;
                let newCol = this.secondary.col;

                switch (this.rotationState) {
                    case 0:
                        newRow = this.primary.row;
                        newCol = this.primary.col + 1;
                        break;
                    case 1:
                        newRow = this.primary.row + 1;
                        newCol = this.primary.col;
                        break;
                    case 2:
                        newRow = this.primary.row;
                        newCol = this.primary.col - 1;
                        break;
                    case 3:
                        newRow = this.primary.row - 1;
                        newCol = this.primary.col;
                        break;
                }

                // Check if the new position is valid
                if (newRow >= 0 && newRow < gridRows && newCol >= 0 && newCol < gridCols && !grid[newRow][newCol]) {
                    this.secondary.row = newRow;
                    this.secondary.col = newCol;
                    this.rotationState = (this.rotationState + 1) % 4;  // Update the rotation state
                }
            }


            randomColor() {
                return ['red', 'blue', 'green', 'yellow'][Math.floor(Math.random() * 4)];
            }

            draw() {
                this.drawBlock(this.primary);
                this.drawBlock(this.secondary);
            }

            drawBlock(block) {
                ctx.fillStyle = block.color;
                ctx.fillRect(block.col * gridSize, block.row * gridSize, gridSize, gridSize);
            }

            collision(rowDelta, colDelta, block) {
                const newRow = block.row + rowDelta;
                const newCol = block.col + colDelta;

                if (newRow >= gridRows || newRow < 0 || newCol >= gridCols || newCol < 0 || grid[newRow][newCol]) {
                    return true;
                }

                return false;
            }

            moveDown() {
                const primaryCollision = this.collision(1, 0, this.primary);
                const secondaryCollision = this.collision(1, 0, this.secondary);

                if (!primaryCollision && !secondaryCollision) {
                    this.primary.row++;
                    this.secondary.row++;
                } else {
                    if (primaryCollision) {
                        grid[this.primary.row][this.primary.col] = this.primary.color;
                        while (!this.collision(1, 0, this.secondary)) {
                            this.secondary.row++;
                        }
                        if (this.secondary.row >= 0) {
                            grid[this.secondary.row][this.secondary.col] = this.secondary.color;
                        }
                    } else if (secondaryCollision) {
                        grid[this.secondary.row][this.secondary.col] = this.secondary.color;
                        while (!this.collision(1, 0, this.primary)) {
                            this.primary.row++;
                        }
                        grid[this.primary.row][this.primary.col] = this.primary.color;
                    }

                    this.checkRemoval();

                    currentBlock = new BlockPair(); // Spawn a new pair only after placing both blocks
                    if (this.collision(0, 0, currentBlock.primary) && this.collision(0, 0, currentBlock.secondary)) {
                        pauseGame();
                        alert('Game Over!');
                    }
                }
            }

            moveLeft() {
                if (!this.collision(0, -1, this.primary) && !this.collision(0, -1, this.secondary)) {
                    this.primary.col--;
                    this.secondary.col--;
                }
            }

            moveRight() {
                if (!this.collision(0, 1, this.primary) && !this.collision(0, 1, this.secondary)) {
                    this.primary.col++;
                    this.secondary.col++;
                }
            }

            checkRemoval() {
                let visited = Array(gridRows).fill(null).map(() => Array(gridCols).fill(false));
                let toRemove = [];

                const dfs = (r, c, color) => {
                    if (r < 0 || r >= gridRows || c < 0 || c >= gridCols || visited[r][c] || grid[r][c] !== color) {
                        return [];
                    }
                    visited[r][c] = true;
                    let cells = [{ r, c }];
                    cells = cells.concat(dfs(r + 1, c, color));
                    cells = cells.concat(dfs(r - 1, c, color));
                    cells = cells.concat(dfs(r, c + 1, color));
                    cells = cells.concat(dfs(r, c - 1, color));
                    return cells;
                }

                for (let r = 0; r < gridRows; r++) {
                    for (let c = 0; c < gridCols; c++) {
                        if (grid[r][c] && !visited[r][c]) {
                            const blocks = dfs(r, c, grid[r][c]);
                            if (blocks.length >= 4) {
                                toRemove = toRemove.concat(blocks);
                            }
                        }
                    }
                }

                toRemove.forEach(cell => {
                    grid[cell.r][cell.c] = null;
                });

                // Gravity: make blocks fall down after removal
                for (let c = 0; c < gridCols; c++) {
                    let emptyRows = [];
                    for (let r = gridRows - 1; r >= 0; r--) {
                        if (!grid[r][c]) {
                            emptyRows.push(r);
                        } else if (emptyRows.length > 0) {
                            grid[emptyRows[emptyRows.length - 1]][c] = grid[r][c];
                            grid[r][c] = null;
                            emptyRows.pop();
                        }
                    }
                }

                if (toRemove.length > 0) {
                    increaseScore(toRemove.length);
                }
            }
        }

        function initializeGrid() {
            for (let r = 0; r < gridRows; r++) {
                grid[r] = [];
                for (let c = 0; c < gridCols; c++) {
                    grid[r][c] = null;
                }
            }
        }

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let r = 0; r < gridRows; r++) {
                for (let c = 0; c < gridCols; c++) {
                    if (grid[r][c]) {
                        ctx.fillStyle = grid[r][c];
                        ctx.fillRect(c * gridSize, r * gridSize, gridSize, gridSize);
                    }
                }
            }
        }

        function increaseScore(points) {
            score += points * 10;
            document.getElementById('score').innerText = score;
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('highScore', highScore);
                document.getElementById('highScore').innerText = highScore;
            }
        }

        function startGame() {
            initializeGrid();
            score = 0;
            document.getElementById('score').innerText = score;
            currentBlock = new BlockPair();  // <-- This is the change
            gameInterval = setInterval(() => {
                drawGrid();
                currentBlock.draw();
                currentBlock.moveDown();
            }, 500);
        }


        function pauseGame() {
            clearInterval(gameInterval);
        }


        // Keyboard control
        document.addEventListener('keydown', function (e) {
            if (!currentBlock) return;

            switch (e.code) {
                case 'ArrowLeft':
                case 'KeyA':
                    currentBlock.moveLeft();
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    currentBlock.moveRight();
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    currentBlock.moveDown();
                    break;
                case 'ArrowUp':
                    currentBlock.rotate();
                    break;
            }

            drawGrid();
            currentBlock.draw();
        });

    </script>
</body>

</html>